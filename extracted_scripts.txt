//// topface
<script>

{
    "imports": {
        "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/",
        
    }
}

</script>
<script>


import * as THREE from 'three';
import { Font } from 'three/addons/fonts/helvetiker_regular.typeface.json';


let camera, scene, renderer, parameters;
let mouseX = 0, mouseY = 0;
let container;

let windowHalfX = 150; // Half of 300px
let windowHalfY = 150; // Half of 300px

const materials = [];

init();
animate();

function init() {
    container = document.getElementById('threejs-container');

    camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 1, 2000);
    camera.position.z = 1000;

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0008);

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    container.appendChild(renderer.domElement);

    // Directly using 'ABC' for nameString
    const nameString = localStorage.getItem('name') || 'ABC';
    const totalParticles = 10000;
    const charactersCount = nameString.length;
    const particlesPerCharacter = Math.floor(totalParticles / charactersCount);

    const textures = [];

    for (let i = 0; i < charactersCount; i++) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 128;
        ctx.fillStyle = 'white';
        ctx.font = '100px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(nameString[i], 100, 100); // Center text

        const texture = new THREE.CanvasTexture(canvas);
        textures.push(texture);
    }

    parameters = textures.map((texture, i) => ([
        [1.0 - i * 0.1, 0.2 - i * 0.05, 0.5], texture, 20 - i * 3
    ]));

    parameters.forEach((param, i) => {
        const [color, sprite, size] = param;
        const geometry = new THREE.BufferGeometry();
        const vertices = [];

        for (let j = 0; j < particlesPerCharacter; j++) {
            const x = Math.random() * 2000 - 1000;
            const y = Math.random() * 2000 - 1000;
            const z = Math.random() * 2000 - 1000;
            vertices.push(x, y, z);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

        const material = new THREE.PointsMaterial({ size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent: true });
        material.color.setHSL(color[0], color[1], color[2]);

        const particles = new THREE.Points(geometry, material);

        particles.rotation.x = Math.random() * 6;
        particles.rotation.y = Math.random() * 6;
        particles.rotation.z = Math.random() * 6;

        scene.add(particles);
        materials.push(material);
    });

    document.body.style.touchAction = 'none';
    document.body.addEventListener('pointermove', onPointerMove);
}

function onPointerMove(event) {
    if (event.isPrimary === false) return;

    mouseX = event.clientX - windowHalfX;
    mouseY = event.clientY - windowHalfY;
}

function animate() {
    requestAnimationFrame(animate);
    render();
}

function render() {
    camera.position.x += (mouseX - camera.position.x) * 0.05;
    camera.position.y += (-mouseY - camera.position.y) * 0.05;
    camera.lookAt(scene.position);
    renderer.render(scene, camera);
}


</script>

//// backface
<script>

    var particleAlphabet = {
        Particle: function(x, y) {
            this.x = x;
            this.y = y;
            this.radius = 3.5;
            this.draw = function(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, this.radius, this.radius);
                ctx.restore();
            };
        },
        init: function(canvas) {
            this.canvas = canvas;
            this.ctx = this.canvas.getContext('2d');
            this.W = canvas.width = window.innerWidth;
            this.H = canvas.height = window.innerHeight;
            this.particlePositions = [];
            this.particles = [];
            this.tmpCanvas = document.createElement('canvas');
            this.tmpCtx = this.tmpCanvas.getContext('2d');

            setInterval(() => {
                this.changeLetter();
                this.getPixels(this.tmpCanvas, this.tmpCtx);
            }, 1200);

            this.makeParticles(1000);
            this.animate();
        },
        currentPos: 0,
        changeLetter: function() {
            var letters = 'APT </>'.split('');
            this.time = letters[this.currentPos];
            this.currentPos = (this.currentPos + 1) % letters.length;
        },
        makeParticles: function(num) {
            for (var i = 0; i <= num; i++) {
                this.particles.push(new this.Particle(this.W / 2 + Math.random() * 400 - 200, this.H / 2 + Math.random() * 400 - 200));
            }
        },
        getPixels: function(canvas, ctx) {
            var keyword = this.time,
                gridX = 6,
                gridY = 6;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.fillStyle = 'red';
            ctx.font = 'italic bold 330px Noto Serif';
            ctx.fillText(keyword, canvas.width / 2 - ctx.measureText(keyword).width / 2, canvas.height / 2 + 100);
            var idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var buffer32 = new Uint32Array(idata.data.buffer);
            if (this.particlePositions.length > 0) this.particlePositions = [];
            for (var y = 0; y < canvas.height; y += gridY) {
                for (var x = 0; x < canvas.width; x += gridX) {
                    if (buffer32[y * canvas.width + x]) {
                        this.particlePositions.push({x: x, y: y});
                    }
                }
            }
        },
        animateParticles: function() {
            var p, pPos;
            for (var i = 0, num = this.particles.length; i < num; i++) {
                p = this.particles[i];
                pPos = this.particlePositions[i];
                if (pPos) {
                    p.x += (pPos.x - p.x) * .3;
                    p.y += (pPos.y - p.y) * .3;
                    p.draw(this.ctx);
                }
            }
        },
        animate: function() {
            requestAnimationFrame(this.animate.bind(this));
            this.ctx.fillStyle = 'rgba(23, 41, 58, .8)';
            this.ctx.fillRect(0, 0, this.W, this.H);
            this.animateParticles();
        }
    };

    window.onload = function() {
        var canvas = document.getElementById('particle-canvas');
        particleAlphabet.init(canvas);
    };

</script>

//// bottomface
<script>

        attribute float scale;
        attribute float letterIndex;

        varying float vLetterIndex;

        void main() {
            vLetterIndex = letterIndex;

            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

            gl_PointSize = scale * ( 300.0 / - mvPosition.z );

            gl_Position = projectionMatrix * mvPosition;
        }
    
</script>
<script>

        uniform vec3 color;
        uniform sampler2D textureSampler[5];

        varying float vLetterIndex;

        void main() {
            vec2 uv = gl_PointCoord;

            // Flip the uv coordinates for all letters
            uv.y = 1.0 - uv.y;

            vec4 textureColor;

            if (vLetterIndex < 0.5) {
                textureColor = texture2D(textureSampler[0], uv);
            } else if (vLetterIndex < 1.5) {
                textureColor = texture2D(textureSampler[1], uv);
            } else if (vLetterIndex < 2.5) {
                textureColor = texture2D(textureSampler[2], uv);
            } else if (vLetterIndex < 3.5) {
                textureColor = texture2D(textureSampler[3], uv);
            } else {
                textureColor = texture2D(textureSampler[4], uv);
            }

            gl_FragColor = vec4(color, 1.0) * textureColor;
        }
    
</script>
<script>

        {
            "imports": {
                "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/"
            }
        }
    
</script>
<script>

        import * as THREE from 'three';

        const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;
        const sprites = [];
        let container;
        let camera, scene, renderer;

        let particles, count = 0;

        let mouseX = 0, mouseY = 0;

        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        const letters = localStorage.getItem('name')? localStorage.getItem('name').split(''): ['<','A','P','T', '/', '>']; // Update with your desired characters

        init();
        animate();

        function init() {
            container = document.createElement( 'div' );
            document.body.appendChild( container );

            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.z = 1000;

            scene = new THREE.Scene();

            const numParticles = AMOUNTX * AMOUNTY;

            const positions = new Float32Array( numParticles * 3 );
            const scales = new Float32Array( numParticles );
            const letterIndices = new Float32Array( numParticles );

            let i = 0, j = 0;

            for ( let ix = 0; ix < AMOUNTX; ix ++ ) {
                for ( let iy = 0; iy < AMOUNTY; iy ++ ) {
                    positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
                    positions[ i + 1 ] = 0; // y
                    positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z

                    scales[ j ] = 1;
                    letterIndices[ j ] = ix % letters.length;

                    i += 3;
                    j ++;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
            geometry.setAttribute( 'scale', new THREE.Float32BufferAttribute( scales, 1 ) );
            geometry.setAttribute( 'letterIndex', new THREE.Float32BufferAttribute( letterIndices, 1 ) );

            for (const letter of letters) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const size = 128;
                canvas.width = size;
                canvas.height = size;
                ctx.fillStyle = 'white';
                ctx.font = '100px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(letter, size / 2, size / 2);

                const texture = new THREE.CanvasTexture(canvas);
                sprites.push(texture);
            }

            // Add empty textures for remaining slots
            while (sprites.length < 5) {
                const canvas = document.createElement('canvas');
                const texture = new THREE.CanvasTexture(canvas);
                sprites.push(texture);
            }

            const material = new THREE.ShaderMaterial( {
                uniforms: {
                    color: { value: new THREE.Color( 0xffffff ) },
                    textureSampler: { value: sprites },
                },
                vertexShader: document.getElementById( 'vertexshader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
                transparent: true
            } );

            particles = new THREE.Points( geometry, material );
            scene.add( particles );

            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            container.style.touchAction = 'none';
            container.addEventListener( 'pointermove', onPointerMove );

            window.addEventListener( 'resize', onWindowResize );
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function onPointerMove( event ) {
            if ( event.isPrimary === false ) return;

            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            camera.position.x += ( mouseX - camera.position.x ) * .05;
            camera.position.y += ( - mouseY - camera.position.y ) * .05;
            camera.lookAt( scene.position );

            const positions = particles.geometry.attributes.position.array;
            const scales = particles.geometry.attributes.scale.array;

            let i = 0, j = 0;

            for ( let ix = 0; ix < AMOUNTX; ix ++ ) {
                for ( let iy = 0; iy < AMOUNTY; iy ++ ) {
                    positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.1 ) * 20 ) +
                                        ( Math.sin( ( iy + count ) * 0.2 ) * 20 );

                    scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 20 +
                                    ( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 20;

                    i += 3;
                    j ++;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.scale.needsUpdate = true;

            renderer.render( scene, camera );

            count += 0.1;
        }
    
</script>

//// frontface
<script>

      {
          "imports": {
              "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/"
          }
      }
    
</script>
<script>

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        let camera, scene, renderer, controls;
        let letters = [];
        let velocities = [];
        let ripples = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            camera.position.set(0, 0, 40);

            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 0).normalize();
            scene.add(directionalLight);

            // Water Base
            const waterGeometry = new THREE.PlaneGeometry(100, 100);
            const waterMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.6 });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -5;
            scene.add(water);

            // Load Font and Create Text
            const loader = new FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const textMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const lettersOptions = ['A', 'P', 'T'];
                lettersOptions.forEach((letter, index) => {
                    const geometry = new TextGeometry(letter, {
                        font: font,
                        size: 0.5,
                        height: 0.1,
                    });
                    for (let i = 0; i < 250; i++) { // Adjust number of particles
                        const letterMesh = new THREE.Mesh(geometry, textMaterial);
                        resetLetterPosition(letterMesh);
                        letters.push(letterMesh);
                        velocities.push(Math.random() * 0.05 + 0.25); // Randomize velocity
                        scene.add(letterMesh);
                    }
                });
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        function resetLetterPosition(letter) {
            letter.position.x = (Math.random() - 0.5) * 50; // Spread across the screen width
            letter.position.y = Math.random() * 30 + 10; // Start above the camera view
            letter.position.z = (Math.random() - 0.5) * 50;
        }

        function addRipple(x, z) {
            const rippleGeometry = new THREE.CircleGeometry(0.1, 32);
            const rippleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
            ripple.position.set(x, -4.9, z);
            ripple.rotation.x = -Math.PI / 2;
            ripples.push({ mesh: ripple, scale: 1 });
            scene.add(ripple);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            letters.forEach((letter, index) => {
                letter.position.y -= velocities[index]; // Apply velocity
                if (letter.position.y < -5) { // Reset position when hitting the water base
                    addRipple(letter.position.x, letter.position.z);
                    resetLetterPosition(letter);
                }
            });

            ripples.forEach(ripple => {
                ripple.scale += 0.1;
                ripple.mesh.scale.set(ripple.scale, ripple.scale, ripple.scale);
                ripple.mesh.material.opacity = Math.max(0, 1 - ripple.scale / 5); // Adjust fade out speed
                if (ripple.mesh.material.opacity === 0) {
                    scene.remove(ripple.mesh);
                }
            });
            ripples = ripples.filter(ripple => ripple.mesh.material.opacity > 0);

            renderer.render(scene, camera);
        }
    
</script>

//// rightface
<script>

        {
            "imports": {
                "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/"
            }
        }
    
</script>
<script>

        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { mergeBufferGeometries } from 'three/addons/utils/BufferGeometryUtils.js';

        const LETTER_SIZE = 20;
        const WING_FLAP_SPEED = 0.04;
        const WING_FLAP_ANGLE = Math.PI / 4;
        const NUM_BIRDS = 20;
        const BOUNDS = 500;
        const BIRD_SPEED =1;
        const GENERATION_INTERVAL = 3000;

        const birds = [];
        let font;

        const loader = new FontLoader();
        loader.load('https://unpkg.com/three@0.156.0/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
            font = loadedFont;
            createBirds();
            setInterval(createBirds, GENERATION_INTERVAL);
        });

        function createBird(letter) {
            const letterShape = new THREE.ShapeGeometry(
                font.generateShapes(letter, LETTER_SIZE)[0]
            );
            letterShape.computeBoundingBox();
            const letterWidth = letterShape.boundingBox.max.x - letterShape.boundingBox.min.x;

            const rightWing = letterShape.clone();
            const leftWing = letterShape.clone();
            leftWing.scale(-1, 1, 1);

            const birdGroup = new THREE.Group();
            const birdMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true });
            
            const rightWingMesh = new THREE.Mesh(rightWing, birdMaterial);
            rightWingMesh.position.x = letterWidth / 2; // Position the right wing
            rightWingMesh.geometry.translate(-letterWidth / 2, 0, 0); // Pivot point adjustment

            const leftWingMesh = new THREE.Mesh(leftWing, birdMaterial);
            leftWingMesh.position.x = -(letterWidth / 2)+2; // Position the left wing
            leftWingMesh.geometry.translate(letterWidth / 2, 0, 0); // Pivot point adjustment

            birdGroup.add(rightWingMesh);
            birdGroup.add(leftWingMesh);

            birdGroup.position.set(
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200 + camera.position.z
            );
            birdGroup.rotateX(Math.PI / 2);
            birdGroup.velocity = new THREE.Vector3(0, 0, -1).multiplyScalar(BIRD_SPEED);
            birdGroup.flapAngle = 0;
            birdGroup.flapSpeed = WING_FLAP_SPEED;
            birdGroup.rightWingMesh = rightWingMesh;
            birdGroup.leftWingMesh = leftWingMesh;

            return birdGroup;
        }

        function updateBirds() {
            birds.forEach((birdGroup) => {
                birdGroup.position.add(birdGroup.velocity);

                if (birdGroup.position.z < -BOUNDS) {
                    scene.remove(birdGroup);
                    birds.splice(birds.indexOf(birdGroup), 1);
                }

                birdGroup.flapAngle += birdGroup.flapSpeed;
                if (birdGroup.flapAngle > WING_FLAP_ANGLE || birdGroup.flapAngle < 0) {
                    birdGroup.flapSpeed = -birdGroup.flapSpeed;
                }

                birdGroup.rightWingMesh.rotation.y = birdGroup.flapAngle;
                birdGroup.leftWingMesh.rotation.y = -birdGroup.flapAngle;

                const opacity = 1 - Math.abs(birdGroup.position.z) / BOUNDS;
                birdGroup.rightWingMesh.material.opacity = opacity;
                birdGroup.leftWingMesh.material.opacity = opacity;
            });
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 200;
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        function createBirds() {
            const letterString =localStorage.getItem('name') ? localStorage.getItem('name') : "<APT/>";
            for (let i = 0; i < NUM_BIRDS; i++) {
                const letter = letterString[i % letterString.length];
                const birdGroup = createBird(letter);
                birds.push(birdGroup);
                scene.add(birdGroup);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateBirds();
            renderer.render(scene, camera);
        }
        animate();
    
</script>

//// leftface
<script>

class Vector {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  add(v) {
    return new Vector(this.x + v.x, this.y + v.y);
  }

  sub(v) {
    return new Vector(this.x - v.x, this.y - v.y);
  }

  getLength() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  setLength(length) {
    var angle = this.getAngle();
    this.x = Math.cos(angle) * length;
    this.y = Math.sin(angle) * length;
  }

  getAngle() {
    return Math.atan2(this.y, this.x);
  }

  addTo(v) {
    this.x += v.x;
    this.y += v.y;
  }

  multiplyBy(value) {
    this.x *= value;
    this.y *= value;
  }

  setAngle(angle) {
    var length = this.getLength();
    this.x = Math.cos(angle) * length;
    this.y = Math.sin(angle) * length;
  }
}

// Your script here, replacing the existing bird animation

const config = {
  text:"</>",
  widthToSpikeLengthRatio: 0.054
};

const colorConfig = {
  particleOpacity: 0.2,
  baseHue: 350,
  hueRange: 9,
  hueSpeed: 0.04,
  colorSaturation: 100,
};

class Planet {
  constructor(x, y, g) {
    this.pos = new Vector(x, y);
    this.g = g;
  }

  draw() {
   // ctx.beginPath();
   // ctx.fillStyle = "white";
    // ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI * 2);
    // ctx.fill();
  }
}

class Particle {
  constructor(x, y) {
    this.pos = new Vector(x, y);
    this.vel = new Vector(0, spikeLength);
  }

  move(force) {
    if (force) {
      this.vel.addTo(force);
    }
    if (this.vel.getLength() > spikeLength) {
      this.vel.setLength(spikeLength);
    }
  }

  draw() {
    let p2 = this.pos.add(this.vel);
    let gradient = ctx.createLinearGradient(this.pos.x, this.pos.y, p2.x, p2.y);
    gradient.addColorStop(0, "rgba(0, 255, 255, 0)"); // Start transparent at the character
    gradient.addColorStop(1, "rgba(0, 255, 255, 1)"); // End in opaque neon blue
    
    ctx.beginPath();
    ctx.moveTo(this.pos.x, this.pos.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = gradient;
    ctx.stroke();
  }
}

let canvas;
let ctx;
let w, h;
let hue;
let particles;
let spikeLength;
let planets;
let A;
let B;
let a;
let b;
let tick;

function setup() {
  tick = 0;
  planets = [];
  let len = Math.round(Math.random() * 3 + 3);
  for (let i = 0; i < len; i++) {
    let p = new Planet(50 + i * 100, 340, i ? 1000 : 4000);
    planets.push(p);
  }
  canvas = document.querySelector("#canvas");
  ctx = canvas.getContext("2d");
  window.addEventListener("resize", reset);
  canvas.addEventListener("mousemove", mousemove);
  reset();
}

function reset() {
  hue = colorConfig.baseHue;
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
  spikeLength = w * config.widthToSpikeLengthRatio;
  A = w / 2.2;
  B = h / 2.2;
  a = Math.round(Math.random() + 2);
  b = Math.round(Math.random() + 2);
  drawText();
}

function mousemove(event) {
  let x = event.clientX;
  let y = event.clientY;
  planets[0].pos.x = x;
  planets[0].pos.y = y;
}

function draw(now) {
  clear();
  requestAnimationFrame(draw);
  updateParticles();
  updatePlanets();
  tick = now / 50;
}

function clear() {
  ctx.clearRect(0, 0, w, h);
}

function drawText() {
  ctx.save();
  let fontSize = w * 0.2;
  ctx.font = "bold " + fontSize + "px Arial, Helvetica, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle"
  ctx.lineWidth = 1;
  ctx.strokeStyle = "white";
  ctx.strokeText(config.text, w/2, h/2);
  ctx.restore();
  let imageData = ctx.getImageData(0, 0, w, h);

  particles = [];
  
  // Define the skip factor to reduce particle count
  // For example, skipping every other pixel (2) will reduce particle count significantly
  // Adjust this value to find the best balance between performance and visual density
  let skipFactor = 2; // Skip every 2 pixels for a moderate performance boost

  for (let x = 0; x < w; x += skipFactor) {
    for (let y = 0; y < h; y += skipFactor) {
      let i = (x + w * y) * 4;
      let average = (imageData.data[i] + 
                     imageData.data[i + 1] + 
                     imageData.data[i + 2] +
                     imageData.data[i + 3]) / 4;
      if (average > 200) {
        let particle = new Particle(x, y);
        particles.push(particle);
      }
    }
  }
  clear();
}

function updatePlanets() {
  let len = planets.length;
  for (let i = 1; i < len; i++) {
    let angle = Math.PI * 2 / (len - 1) * i;
    let x = A * Math.sin(a * tick / 100 + angle) + w/2;
    let y = B * Math.sin(b * tick / 100 + angle) + h/2;
    let p = planets[i];
    p.pos.x = x;
    p.pos.y = y;
    p.draw();
  }
}

function updateParticles() {
  hue += colorConfig.hueSpeed;
  let h = Math.sin(hue) * colorConfig.hueRange + colorConfig.baseHue;
  ctx.strokeStyle = `hsla(180, 100%, 50%, 1)`;
  particles.forEach(p => {
    planets.forEach(planet => {
      let d = p.pos.sub(planet.pos);
      let length = d.getLength();
      let g = planet.g / length;
      if (g > 40) {
        g = 40;
      }
      d.setLength(g);
      p.move(d);
    });
    p.draw();
  });
}

setup();
draw(1);

</script>

