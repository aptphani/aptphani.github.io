<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>
    Interactive Three.js Scene with Face Names and Laser Animation
  </title>
  <style>
    body {
      margin: 0;
    }

    canvas {
      display: block;
    }

    #frontFaceCanvas {
      display: block;
      position: absolute;
      top: 0;
      left: auto;
      z-index: 999;
      width: 100%;
      height: 100%;
      background-color: rgba(9, 5, 77, 1);
    }

    #backFaceCanvas {
      display: block;
      position: absolute;
      top: auto;
      left: auto;
      z-index: 999;
      width: 100%;
      height: 90%;
      background-color: rgb(7, 44, 84);
    }

    #modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0%;
      width: 100%;
      height: 100%;
      z-index: 999;
      background-color: rgb(255, 254, 254);
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(168, 13, 13, 0.5);
      padding: 20px;
      justify-content: center;
      align-items: center;
    }

    #modal>canvas {
      width: 100%;
      height: 100%;
      background-color: rgb(3, 45, 78);
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }

    #modal>button {
      position: absolute;
      top: -8%;
      right: 3%;
      display: block;
      background: rgb(230, 133, 133);
      color: black;
      font-size: 24px;
      cursor: pointer;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      border-color: black;
      border-width: 2px;
      border-style: solid;
    }
  </style>
</head>

<body>
  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/",
          "tween": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.min.js"
        }
      }
    </script>

  <script type="module">
    import * as THREE from "three";
    import TWEEN from "tween";
    /*import LeftFace from "./LeftFace.js";
      import RightFace from "./RightFace.js";
      import TopFace from "./TopFace.js";
      import BottomFace from "./BottomFace.js";
      import FrontFace from "./FrontFace.js";*/
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const faceNames = ["front", "back", "top", "bottom", "right", "left"];
    const videoPaths = [
      "/ani/videos/Video1.mp4",
      "/ani/videos/Video6.mp4",
      "/ani/videos/Video2.mp4",
      "/ani/videos/Video3.mp4",
      "/ani/videos/Video4.mp4",
      "/ani/videos/Video5.mp4",
    ];
    const videoMaterials = videoPaths.map(
      (path) =>
        new THREE.MeshBasicMaterial({
          map: createVideoTexture(path),
          side: THREE.DoubleSide,
        })
    );
    const planeGeometry = new THREE.PlaneGeometry(4, 4);
    const cube = new THREE.Group();
  //  document.addEventListener(
  //    "click",
   //   function (event) {
   //     var modal = document.getElementById("modal");
    //    if (modal) {
   //       document.body.removeChild(modal);
  //      }
   //     new TWEEN.Tween(cube.position)
   //       .to({ x: 0, y: 15, z: 40 }, 1000)
  //        .easing(TWEEN.Easing.Exponential.InOut)
  //        .start();
  //      rotationSpeed = 0.005;
  //    },
  //    true
  //  ); // Use capture mode to ensure this runs before other click events

    videoMaterials.forEach((material, index) => {
      const plane = new THREE.Mesh(planeGeometry, material);
      plane.name = faceNames[index];
      cube.add(plane);
    });
    // Position and rotate planes to form the cube
    arrangeCubeFaces(cube.children);
    scene.add(cube);

    cube.position.set(0, 15, 40);
    camera.position.set(0, 15, 50);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let lastClickTime = 0;
    let rotationSpeed = 0.005;

    document.addEventListener("mousedown", onMouseDown);
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("click", onClick);

    setupLighting();
    createFloor();
    animate();

    function createVideoTexture(videoPath) {
      const video = document.createElement("video");
      video.src = videoPath;
      video.loop = true;
      video.muted = true;
      video.playbackRate = 1.0;
      video.crossOrigin = "anonymous";
      const texture = new THREE.VideoTexture(video);
      video.addEventListener("loadedmetadata", () => {
        video.play();
      });
      return texture;
    }

    function arrangeCubeFaces(children) {
      // Front
      children[0].position.set(0, 0, -2);
      children[0].rotation.y = Math.PI;
      // Back
      children[1].position.set(0, 0, 2);

      // Top
      children[2].position.set(0, 2, 0);
      children[2].rotation.x = -Math.PI / 2;
      // Bottom
      children[3].position.set(0, -2, 0);
      children[3].rotation.x = Math.PI / 2;
      // Right
      children[4].position.set(2, 0, 0);
      children[4].rotation.y = Math.PI / 2;
      // Left
      children[5].position.set(-2, 0, 0);
      children[5].rotation.y = -Math.PI / 2;
    }

    function onMouseDown(event) {
      isDragging = true;
      previousMousePosition.x = event.clientX;
      previousMousePosition.y = event.clientY;
    }

    function onMouseMove(event) {
      if (isDragging) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y,
        };
        const rotateAngleX = ((deltaMove.y * Math.PI) / 180) * 0.5;
        const rotateAngleY = ((deltaMove.x * Math.PI) / 180) * 0.5;
        cube.rotation.x += rotateAngleX;
        cube.rotation.y += rotateAngleY;
        previousMousePosition = { x: event.clientX, y: event.clientY };
      }
    }

    function onMouseUp() {
      isDragging = false;
    }

    function onClick(event) {
      if (!isDragging) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(cube.children);
        if (intersects.length > 0) {
          const now = Date.now();
          const delta = now - lastClickTime;
          lastClickTime = now;
          if (delta < 300) {
            new TWEEN.Tween(cube.position)
              .to({ x: -50, y: 5, z: -20 }, 1000)
              .easing(TWEEN.Easing.Exponential.InOut)
              .onComplete(function () {
                rotationSpeed = 0;
                const clickedFaceName = intersects[0].object.name;
                showModal(clickedFaceName);
              })
              .start();
          } else {
          }
        }
      }
    }

    function setupLighting() {
      const spotLight = new THREE.SpotLight(0xffffff, 1);
      spotLight.position.set(0, 20, 20);
      spotLight.angle = Math.PI / 2;
      spotLight.penumbra = 0.1;
      spotLight.decay = 0;
      spotLight.distance = 1000;
      spotLight.castShadow = true;
      scene.add(spotLight);
    }

    function createFloor() {
      const floorGeometry = new THREE.PlaneGeometry(200, 200);
      const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0xf7f5da,
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -5;
      floor.receiveShadow = true;
      scene.add(floor);
    }

    function animate() {
      if (!isDragging) {
        cube.rotation.x += rotationSpeed;
        cube.rotation.y += rotationSpeed;
      }
      requestAnimationFrame(animate);
      TWEEN.update();
      renderer.render(scene, camera);
    }
  </script>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script>
    function showModal(faceName) {
      var modal = document.createElement("div");
      modal.id = "modal";
      modal.style.display = "flex";
      document.body.appendChild(modal);

      var closeButton = document.createElement("button");
      closeButton.innerText = "X";
      closeButton.onclick = function () {
        document.body.removeChild(modal);
        new TWEEN.Tween(cube.position)
          .to({ x: 0, y: 15, z: 40 }, 1000)
          .easing(TWEEN.Easing.Exponential.InOut)
          .start();
        rotationSpeed = 0.005;
      };
      modal.appendChild(closeButton);
      var canvas = document.createElement("canvas");
      canvas.id = "temp";
      canvas.width = window.innerWidth * 0.98; 
      canvas.height = window.innerHeight * 0.45; 

      if (faceName === "front") {
        canvas.id = "frontFaceCanvas";
        modal.appendChild(canvas);
        initializeFrontFaceAnimation(canvas.id);
      } else if (faceName === "back") {
        canvas.id = "backFaceCanvas";
        modal.appendChild(canvas);
        initializeBackFaceAnimation();
      }
      else if (faceName === "right") {
        canvas.id = "rightFaceCanvas";
        modal.appendChild(canvas);
        initializeRightFaceAnimation(canvas.id);
      }
      else if (faceName === "bottom") {
        canvas.id = "bottomFaceCanvas";
        modal.appendChild(canvas);
        initializeBottomFaceAnimation(canvas.id);
      }
      else if (faceName === "top") {
        canvas.id = "topFaceCanvas";
        modal.appendChild(canvas);
        initializeTopFaceAnimation(canvas.id);
        modal.addEventListener("click", function (event) {
          event.stopPropagation();
        });
   //     document.addEventListener("click", function closeModal(event) {
   //       if (modal.parentNode) {
   //         document.body.removeChild(modal);
   //       }
   //     });
      }}

      function initializeFrontFaceAnimation(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
          console.error("FrontFace canvas element not found");
          return;
        }
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth * 0.98; // Adjusted to match modal canvas width
        canvas.height = window.innerHeight * 0.45; // Adjusted to match modal canvas height

        let particlePositions = [];
        let particles = [];
        const letters = "APT </>".split("");
        let currentPos = 0;
        let W = canvas.width;
        let H = canvas.height;

        function Particle(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 4;

          this.draw = function () {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.fillStyle = "rgb(10,242,122)";
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * 0.5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
          };
        }

        function changeLetter() {
          time = letters[currentPos];
          currentPos = (currentPos + 1) % letters.length;
        }

        function makeParticles(num) {
          for (let i = 0; i <= num; i++) {
            particles.push(
              new Particle(
                W / 2 + Math.random() * 400 - 200,
                H / 2 + Math.random() * 400 - 200
              )
            );
          }
        }

        function getPixels() {
          const keyword = letters[currentPos],
            gridX = 6,
            gridY = 6;

          const tmpCanvas = document.createElement("canvas"),
            tmpCtx = tmpCanvas.getContext("2d");

          tmpCanvas.width = W;
          tmpCanvas.height = H;
          tmpCtx.fillStyle = "red";
          tmpCtx.font = "italic bold 400px Noto Serif";
          const textHeight = 500; // Approximation of text height, adjust as needed
          tmpCtx.fillText(
            keyword,
            W / 2 - tmpCtx.measureText(keyword).width / 1.5,
            H / 2 + textHeight / 4
          );

          const idata = tmpCtx.getImageData(
            0,
            0,
            tmpCanvas.width,
            tmpCanvas.height
          ),
            buffer32 = new Uint32Array(idata.data.buffer);

          particlePositions = [];
          for (let y = 0; y < tmpCanvas.height; y += gridY) {
            for (let x = 0; x < tmpCanvas.width; x += gridX) {
              if (buffer32[y * tmpCanvas.width + x]) {
                particlePositions.push({ x, y });
              }
            }
          }
        }

        function animateParticles() {
          for (let i = 0, num = particles.length; i < num; i++) {
            const p = particles[i],
              pPos = particlePositions[i];
            if (pPos) {
              p.x += (pPos.x - p.x) * 0.3;
              p.y += (pPos.y - p.y) * 0.3;
              p.draw();
            }
          }
        }

        function animate() {
          requestAnimationFrame(animate);
          ctx.fillStyle = "rgba(9, 5, 77, 1)";
          ctx.fillRect(0, 0, W, H);
          animateParticles();
        }

        // Initialize the animation
        setInterval(() => {
          changeLetter();
          getPixels();
        }, 600);

        makeParticles(10000);
        animate();
      }

      function initializeBackFaceAnimation() {
        const canvas = document.getElementById("backFaceCanvas");
        if (!canvas) {
          console.error("BackFace canvas element not found");
          return;
        }
        const ctx = canvas.getContext("2d", {
          willReadFrequently: true,
        });
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const colors = [
          "#FF4500", // Orangered
          "#00CED1", // Dark Turquoise
          "#FF00FF", // Magenta
          "#FFFF00", // Yellow
          "#7FFFD4", // Aquamarine
          "#FF1493", // Deep Pink
          "#00FF00", // Lime
          "#8A2BE2", // Blue Violet
          "#FF6347", // Tomato
          "#00FFFF", // Cyan
          "#FF8C00", // Dark Orange
          "#9400D3", // Dark Violet
        ];

        const userName = localStorage.getItem("userName") || "<APT/>";

        class Particle {
          constructor(effect, x, y) {
            this.effect = effect;
            this.x = Math.random() * this.effect.canvasWidth;
            this.y = Math.random() * this.effect.canvasHeight;
            this.originX = Math.floor(x);
            this.originY = Math.floor(y);
            this.size = Math.random() * 5 + 5; 
            this.color = colors[Math.floor(Math.random() * colors.length)];
            this.dx = 0;
            this.dy = 0;
            this.vx = 0;
            this.vy = 0;
            this.force = 10;
            this.angle = 0;
            this.distance = 0;
            this.friction = 0.8;
            this.ease = 1;
          }
          update() {
            this.dx = this.effect.mouse.x - this.x;
            this.dy = this.effect.mouse.y - this.y;
            this.distance = this.dx * this.dx + this.dy * this.dy;
            this.force = -this.effect.mouse.radius / this.distance;
            if (this.distance < this.effect.mouse.radius) {
              this.angle = Math.atan2(this.dy, this.dx);
              this.vx += this.force * Math.cos(this.angle);
              this.vy += this.force * Math.sin(this.angle);
            }
            this.x +=
              (this.vx *= this.friction) +
              (this.originX - this.x) * this.ease;
            this.y +=
              (this.vy *= this.friction) +
              (this.originY - this.y) * this.ease;
          }
          draw() {
            this.effect.context.fillStyle = this.color;
            this.effect.context.beginPath();
            this.effect.context.arc(
              this.x,
              this.y,
              this.size,
              0,
              2 * Math.PI
            );
            this.effect.context.fill();
          }
        }

        class Effect {
          constructor(context, canvasWidth, canvasHeight) {
            this.context = context;
            this.canvasWidth = canvasWidth;
            this.canvasHeight = canvasHeight;
            this.particles = [];
            this.gap = 5;
            this.mouse = {
              radius: 800 * 800,
              x: undefined,
              y: undefined,
            };
            window.addEventListener("mousemove", (event) => {
              const rect = canvas.getBoundingClientRect();
              const scaleX = canvas.width / rect.width;
              const scaleY = canvas.height / rect.height;
              this.mouse.x = (event.clientX - rect.left) * scaleX;
              this.mouse.y = (event.clientY - rect.top) * scaleY;
            });
            window.addEventListener("mouseout", () => {
              this.mouse.x = undefined;
              this.mouse.y = undefined;
            });
            this.wrapText(userName);
          }
          wrapText(text) {
            this.context.font = "500px Arial";
            this.context.fillStyle = "white";
            this.context.textAlign = "center";
            this.context.fillText(
              text,
              this.canvasWidth / 2,
              this.canvasHeight / 1.8
            );
            this.convertToParticles();
          }
          convertToParticles() {
            this.particles = [];
            const imageData = this.context.getImageData(
              0,
              0,
              this.canvasWidth,
              this.canvasHeight
            );
            const data = imageData.data;
            for (let y = 0; y < this.canvasHeight; y += this.gap) {
              for (let x = 0; x < this.canvasWidth; x += this.gap) {
                const index = (y * this.canvasWidth + x) * 4;
                if (data[index + 3] > 128) {
                  this.particles.push(new Particle(this, x, y));
                }
              }
            }
          }
          render() {
            this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            this.particles.forEach((particle) => {
              particle.update();
              particle.draw();
            });
          }
        }

        let effect = new Effect(ctx, canvas.width, canvas.height);

        function animate() {
          effect.render();
          requestAnimationFrame(animate);
        }
        animate();

        window.addEventListener("resize", function () {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          effect = new Effect(ctx, canvas.width, canvas.height);
          effect.wrapText(userName); // Re-generate text and particles for new dimensions
        });
      }
      
      async function initializeBottomFaceAnimation(canvasId) {
        if (typeof BABYLON === 'undefined') {
            await import('https://cdn.babylonjs.com/babylon.js');
        }
    
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error("BottomFace canvas element not found");
            return;
        }
    
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4( 1/ 255, 4/ 255, 43/ 255, 1); // Dark navy blue background
    
        const camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 4, 1000, BABYLON.Vector3.Zero(), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(canvas, true);
    
        const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
    
        // Wave parameters
        const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;
        let count = 0;
    
        // Store all planes for animation
        const planes = [];
    
        for (let ix = 0; ix < AMOUNTX; ix++) {
            for (let iy = 0; iy < AMOUNTY; iy++) {
                const index = Math.floor(Math.random() * 3);
                const letter = ['A', 'P', 'T'][index];
                const plane = createLetterParticle(letter, ix, iy, SEPARATION, scene);
                planes.push(plane);
            }
        }
    
        function createLetterParticle(letter, ix, iy, SEPARATION, scene) {
            const dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", {width: 512, height: 512}, scene, true);
            dynamicTexture.drawText(letter, 75, 400, "bold 440px Arial", "#07f7df", "transparent");
            dynamicTexture.hasAlpha = true;
    
            const plane = BABYLON.MeshBuilder.CreatePlane("textPlane", {size: 20}, scene);
            plane.position.x = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2);
            plane.position.z = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2);
            plane.position.y = 0;
    
            const material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
            material.diffuseTexture = dynamicTexture;
            material.useAlphaFromDiffuseTexture = true;
            plane.material = material;
    
            return plane;
        }
    
        scene.registerBeforeRender(function () {
            const time = performance.now();
    
            for (let i = 0, l = planes.length; i < l; i++) {
                const plane = planes[i];
                const ix = (i % AMOUNTX), iy = Math.floor(i / AMOUNTX);
    
                plane.position.y = (Math.sin((ix + count) * 0.3) * 50) + (Math.sin((iy + count) * 0.5) * 50);
                plane.rotation.z = Math.sin((ix + count) * 0.3) * Math.PI * 0.2;
            }
    
            count += 0.1;
        });
    
        engine.runRenderLoop(() => {
            scene.render();
        });
    
        window.addEventListener('resize', () => {
            engine.resize();
        });
    }
    async function initializeRightFaceAnimation(canvasId) {
      if (typeof BABYLON === 'undefined') {
          await import('https://cdn.babylonjs.com/babylon.js');
      }
  
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
          console.error("RightFace canvas element not found");
          return;
      }
  
      const engine = new BABYLON.Engine(canvas, true);
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0, 0, 0, 1); // Black background to match the Three.js example
  
      const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2, 500, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, true);
  
      const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
  
      // Simulate "planets" with invisible spheres
      let planets = [];
      const numberOfPlanets = 4; // Number of repellers
      for (let i = 0; i < numberOfPlanets; i++) {
          let planet = BABYLON.MeshBuilder.CreateSphere("planet" + i, {diameter: 10}, scene);
          planet.isVisible = false; // Make planets invisible
          planets.push(planet);
      }
  
      // Randomly position planets off-screen
      planets.forEach((planet, index) => {
          planet.position.x = Math.random() * 1000 - 500;
          planet.position.y = Math.random() * 1000 - 500;
          planet.position.z = Math.random() * 1000 - 500;
      });
  
      // Create particles
      let particles = [];
      const particlesCount = 200;
      for (let i = 0; i < particlesCount; i++) {
          let particle = BABYLON.MeshBuilder.CreateBox("particle" + i, {size: 5}, scene);
          particle.position.x = Math.random() * 1000 - 500;
          particle.position.y = Math.random() * 1000 - 500;
          particle.position.z = Math.random() * 1000 - 500;
  
          particles.push(particle);
      }
  
      // Animation
      scene.registerBeforeRender(() => {
          particles.forEach((particle) => {
              planets.forEach((planet) => {
                  let forceDirection = planet.position.subtract(particle.position);
                  let distance = forceDirection.length() - (planet.scaling.x * 10 / 2);
                  let strength = Math.min(10 / (distance * distance), 10);
                  forceDirection.normalize();
                  forceDirection.scaleInPlace(strength);
                  particle.position.addInPlace(forceDirection);
              });
          });
      });
  
      engine.runRenderLoop(() => {
          scene.render();
      });
  
      window.addEventListener('resize', () => {
          engine.resize();
      });
  }
  
    function createParticles(scene) {
      const AMOUNTX = 50, AMOUNTY = 50;
      const SEPARATION = 100;

      // Generate particles
      for (let i = 0; i < AMOUNTX; i++) {
        for (let j = 0; j < AMOUNTY; j++) {
          const box = BABYLON.MeshBuilder.CreateBox("box", { size: 10 }, scene);
          box.position.x = i * SEPARATION - ((AMOUNTX * SEPARATION) / 2);
          box.position.z = j * SEPARATION - ((AMOUNTY * SEPARATION) / 2);
          box.position.y = 0; // Adjust as necessary

          // Apply materials, textures, or other properties as needed
        }
      }

      // This could also return a more complex particle system if needed
    }

    // Usage example, assuming you have a specific canvas element for this
    initializeBottomFaceAnimation("bottomFaceCanvas");
     function initializeTopFaceAnimation(canvasId) {
      let engine, scene, camera;
      let letters = [];
      let ripples = [];
      let water;
      init();
      animate();
      
      function init() {
          const canvas = document.getElementById(canvasId);
          if (!canvas) {
              console.error("TopFace canvas element not found");
              return;
          }
      
          engine = new BABYLON.Engine(canvas, true);
          scene = new BABYLON.Scene(engine);
          scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);
      
          camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 2, 80, new BABYLON.Vector3(0, 0, 0), scene);
          camera.attachControl(canvas, true);
      
          new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene).intensity = 0.7;
      
          waterMaterial = new BABYLON.StandardMaterial("waterMaterial", scene);
          waterMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
          waterMaterial.alpha = 0.6;
          water = BABYLON.MeshBuilder.CreateGround("water", { width: 300, height: 300 }, scene);
          water.material = waterMaterial;
          water.position.y = -30;
      
          createTextParticles();
      }
      
      function createTextParticles() {
          const lettersOptions = ['A', 'P', 'T'];
      
          lettersOptions.forEach(letter => {
              for (let i = 0; i < 300; i++) {
                  const plane = BABYLON.MeshBuilder.CreatePlane("textPlane", { width: 2, height: 2 }, scene);
                  const dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 512, scene, true);
                  dynamicTexture.drawText(letter, 75, 400, "bold 440px Arial", "white", "transparent", true);
                  dynamicTexture.hasAlpha = true;
      
                  const material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
                  material.diffuseTexture = dynamicTexture;
                  material.useAlphaFromDiffuseTexture = true;
      
                  plane.material = material;
                  plane.position = new BABYLON.Vector3(
                      Math.random() * 300 - 150,
                      Math.random() * 90 + 30,
                      Math.random() * 300 - 150
                  );
                  plane.metadata = { velocity: -Math.random() * 0.5 - 0.5 };
      
                  letters.push(plane);
              }
          });
      }
      
      function createRipple(position) {
          const ripple = BABYLON.MeshBuilder.CreateTorus("ripple", { diameter: 1.5, thickness: 0.15, tessellation: 32 }, scene);
          ripple.position = new BABYLON.Vector3(position.x, water.position.y - 20, position.z - 20);
          ripple.rotation.x = Math.PI / 2;
          const material = new BABYLON.StandardMaterial("rippleMat", scene);
          material.diffuseColor = new BABYLON.Color3(0.0118, 0.9882, 0.9569);
          material.alpha = 1;
          ripple.material = material;
      
          ripples.push({ mesh: ripple, scale: 1, alpha: material.alpha, maxSize: 9 });
      }
      
      function animate() {
          engine.runRenderLoop(() => {
              letters.forEach(letter => {
                  letter.position.y += letter.metadata.velocity;
                  if (letter.position.y < -90) {
                      const impactPosition = new BABYLON.Vector3(letter.position.x, -4.95, letter.position.z);
                      createRipple(impactPosition);
                      letter.position.y = 90 + Math.random() * 30;
                      letter.position.x = Math.random() * 300 - 150;
                      letter.position.z = Math.random() * 300 - 150;
                  }
              });
      
              ripples.forEach((ripple, index) => {
                  ripple.scale += 0.05;
                  ripple.alpha -= 0.02;
                  ripple.mesh.scaling.x = ripple.mesh.scaling.y = ripple.scale;
                  ripple.mesh.material.alpha = ripple.alpha;
      
                  if (ripple.scale > ripple.maxSize || ripple.alpha <= 0) {
                      ripple.mesh.dispose();
                      ripples.splice(index, 1);
                  }
              });
      
              scene.render();
          });
      }
      }
  </script>
</body>

</html>