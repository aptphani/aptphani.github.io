<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>
      Interactive Three.js Scene with Face Names and Laser Animation
    </title>
    <style>
      body {
        margin: 0;
      }

      Copy code canvas {
        display: block;
      }

      #modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0%;
        width: 100%;
        height: 100%;
        z-index: 999;
        background-color: rgb(255, 254, 254);
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(47, 4, 122, 0.5);
        padding: 20px;
        justify-content: center;
        align-items: center;
      }

      #modal > canvas {
        width: 90%;
        height: 90%;
        background-image: radial-gradient(rgb(3, 6, 106), rgb(0, 0, 41));
        display: block;
        position: absolute;
        top: 5%;
        left: 5%;
        margin: auto;
      }

      #modal > button {
        position: absolute;
        top: -8%;
        right: 3%;
        display: block;
        background: rgb(230, 133, 133);
        color: black;
        font-size: 24px;
        cursor: pointer;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        border-color: black;
        border-width: 2px;
        border-style: solid;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/",
          "tween": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.min.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import TWEEN from "tween";
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      const faceNames = ["front", "back", "top", "bottom", "right", "left"];
      const planeGeometry = new THREE.PlaneGeometry(4, 4);
      const cube = new THREE.Group();
      faceNames.forEach((faceName, index) => {
        const plane = new THREE.Mesh(
          planeGeometry,
          new THREE.MeshBasicMaterial()
        );
        plane.name = faceName;
        cube.add(plane);
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        canvas.id = `${faceName}FaceCanvas`;
        document.body.appendChild(canvas);
        switch (faceName) {
          case "front":
            initializeFrontFaceAnimation(canvas.id);
            break;
          case "back":
            initializeBackFaceAnimation(canvas.id);
            break;
          case "top":
            initializeTopFaceAnimation(canvas.id);
            break;
          case "bottom":
            initializeBottomFaceAnimation(canvas.id);
            break;
          case "right":
            initializeRightFaceAnimation(canvas.id);
            break;
          case "left":
            initializeLeftFaceAnimation(canvas.id);
            break;
        }
        const texture = new THREE.CanvasTexture(canvas);
        plane.material.map = texture;
      }); // Position and rotate planes to form the cube arrangeCubeFaces(cube.children); scene.add(cube); cube.position.set(0, 15, 40); camera.position.set(0, 15, 50); const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); let isDragging = false; let previousMousePosition = { x: 0, y: 0 }; let lastClickTime = 0; let rotationSpeed = 0.005; document.addEventListener("mousedown", onMouseDown); document.addEventListener("mousemove", onMouseMove); document.addEventListener("mouseup", onMouseUp); document.addEventListener("click", onClick); setupLighting(); createFloor(); animate(); function arrangeCubeFaces(children) { // Front children[0].position.set(0, 0, -2); children[0].rotation.y = Math.PI; // Back children[1].position.set(0, 0, 2); // Top children[2].position.set(0, 2, 0); children[2].rotation.x = -Math.PI / 2; // Bottom children[3].position.set(0, -2, 0); children[3].rotation.x = Math.PI / 2; // Right children[4].position.set(2, 0, 0); children[4].rotation.y = Math.PI / 2; // Left children[5].position.set(-2, 0, 0); children[5].rotation.y = -Math.PI / 2; } function onMouseDown(event) { isDragging = true; previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY; } function onMouseMove(event) { if (isDragging) { const deltaMove = { x: event.clientX - previousMousePosition.x, y: event.clientY - previousMousePosition.y, }; const rotateAngleX = ((deltaMove.y * Math.PI) / 180) * 0.5; const rotateAngleY = ((deltaMove.x * Math.PI) / 180) * 0.5; cube.rotation.x += rotateAngleX; cube.rotation.y += rotateAngleY; previousMousePosition = { x: event.clientX, y: event.clientY }; } } function onMouseUp() { isDragging = false; } function onClick(event) { if (!isDragging) { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(cube.children); if (intersects.length > 0) { const now = Date.now(); const delta = now - lastClickTime; lastClickTime = now; if (delta < 300) { new TWEEN.Tween(cube.position) .to({ x: -50, y: 5, z: -20 }, 1000) .easing(TWEEN.Easing.Exponential.InOut) .onComplete(function () { rotationSpeed = 0; const clickedFaceName = intersects[0].object.name; showModal(clickedFaceName); }) .start(); } else { } } } } function setupLighting() { const spotLight = new THREE.SpotLight(0xffffff, 1); spotLight.position.set(0, 20, 20); spotLight.angle = Math.PI / 2; spotLight.penumbra = 0.1; spotLight.decay = 0; spotLight.distance = 1000; spotLight.castShadow = true; scene.add(spotLight); } function createFloor() { const floorGeometry = new THREE.PlaneGeometry(200, 200); const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xf7f5da, }); const floor = new THREE.Mesh(floorGeometry, floorMaterial); floor.rotation.x = -Math.PI / 2; floor.position.y = -5; floor.receiveShadow = true; scene.add(floor); } function animate() { if (!isDragging) { cube.rotation.x += rotationSpeed; cube.rotation.y += rotationSpeed; } requestAnimationFrame(animate); TWEEN.update(); renderer.render(scene, camera); }
    </script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script>
      function showModal(faceName, cube) { // ... (keep the existing showModal function code) } // ... (keep the existing canvas animation functions)
    </script>
  </body>
</html>
