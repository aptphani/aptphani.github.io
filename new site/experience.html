<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Interactive Three.js Scene</title>
    <link
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
      #modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 999;
        background: radial-gradient(circle, navy 0%, #010a30 80%);
        justify-content: center;
        align-items: center;
        padding: 20px;
        overflow: hidden;
      }
      #cube_toast {
        position: relative;
        top: 5%;
        right: 50%;
        display: flex;
        float: left;
        z-index: 9001;
        background-color: rgb(247, 132, 108);
        color: rgb(18, 6, 54);
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
        box-shadow: #d7f802;
      }
      #modal > canvas {
        z-index: 1000;
        position: absolute;
        height: 100%;
        width: 100%;
      }
      .toast {
        position: absolute;
        top: 10%;
        right: 10%;
        z-index: 1001;
        background-color: #0af;
        color: white;
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
      }
      .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1002;
        background-color: #ff6b35;
        color: black;
        border: none;
        padding: 5px 10px;
        font-size: 16px;
        cursor: pointer;
        border-radius: 5px;
      }
    </style>
  </head>

  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/",
          "tween": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.min.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import TWEEN from "tween";
      /*import LeftFace from "./LeftFace.js";
      import RightFace from "./RightFace.js";
      import TopFace from "./TopFace.js";
      import BottomFace from "./BottomFace.js";
      import FrontFace from "./FrontFace.js";*/
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const faceNames = ["front", "top", "bottom", "right", "left", "back"];
      const videoPaths = [
        "Video1.mp4",
        "Video2.mp4",
        "Video3.mp4",
        "Video4.mp4",
        "Video5.mp4",
        "Video6.mp4",
      ];
      const videoMaterials = videoPaths.map(
        (path) =>
          new THREE.MeshBasicMaterial({
            map: createVideoTexture(path),
            side: THREE.DoubleSide,
          })
      );
      const planeGeometry = new THREE.PlaneGeometry(4, 4);
      var cube = new THREE.Group();

      videoMaterials.forEach((material, index) => {
        const plane = new THREE.Mesh(planeGeometry, material);
        plane.name = faceNames[index];
        cube.add(plane);
      });
      // Position and rotate planes to form the cube
      arrangeCubeFaces(cube.children);
      scene.add(cube);

      cube.position.set(0, 15, 40);
      camera.position.set(0, 15, 50);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let isDragging = false;
      let candrag = true;
      let previousMousePosition = { x: 0, y: 0 };
      let lastClickTime = 0;
      let rotationSpeed = 0.005;

      document.addEventListener("mousedown", onMouseDown);
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
      document.addEventListener("click", onClick);

      setupLighting();
      createFloor();
      const instructionPlane = createInstructionPlane();
      animate();

      scene.add(instructionPlane);
      function createInstructionPlane() {
        const planeWidth = 10;
        const planeHeight = 2;
        const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const instructionTexture = createInstructionTexture();
        const planeMaterial = new THREE.MeshBasicMaterial({
          map: instructionTexture,
          transparent: true,
          side: THREE.DoubleSide, // Ensure the material is visible from both sides
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);

        // Position the plane in front of the camera
        const distance = 30; // Distance in front of the camera
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        cameraDirection.multiplyScalar(distance);
        plane.position.copy(camera.position).add(cameraDirection);

        // Ensure the plane always faces the camera
        plane.lookAt(camera.position);

        return plane;
      }
      function createInstructionTexture() {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 1024;
        canvas.height = 256;

        context.fillStyle = "rgba(0, 255, 255, 0.5)";
        context.fillRect(0, 0, canvas.width, canvas.height);

        context.font = "48px Arial";
        context.fillStyle = "white";
        context.textAlign = "left";
        context.textBaseline = "middle";
        const text =
          "Drag the cube to rotate. Double-click a face to select and experience an animation pattern";
        const lines = text.split(". ");
        const lineHeight = 60;
        const startY = (canvas.height - (lines.length - 1) * lineHeight) / 2;
        lines.forEach((line, index) => {
          context.fillText(line, canvas.width / 2, startY + index * lineHeight);
        });

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
      }
      var instructionVisible = true;
      document.addEventListener("click", function () {
        instructionVisible = false;
        instructionPlane.visible = false;
      });

      function createVideoTexture(videoPath) {
        const video = document.createElement("video");
        video.src = videoPath;
        video.loop = true;
        video.muted = true;
        video.playbackRate = 1.0;
        video.crossOrigin = "anonymous";
        const texture = new THREE.VideoTexture(video);
        video.addEventListener("loadedmetadata", () => {
          video.play();
        });
        return texture;
      }

      function arrangeCubeFaces(children) {
        // Front
        children[0].position.set(0, 0, -2);
        children[0].rotation.y = Math.PI;
        // Back
        children[1].position.set(0, 0, 2);

        // Top
        children[2].position.set(0, 2, 0);
        children[2].rotation.x = -Math.PI / 2;
        // Bottom
        children[3].position.set(0, -2, 0);
        children[3].rotation.x = Math.PI / 2;
        // Right
        children[4].position.set(2, 0, 0);
        children[4].rotation.y = Math.PI / 2;
        // Left
        children[5].position.set(-2, 0, 0);
        children[5].rotation.y = -Math.PI / 2;
      }

      function onMouseDown(event) {
        isDragging = true;
        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
      }

      function onMouseMove(event) {
        if (isDragging && candrag) {
          const deltaMove = {
            x: event.clientX - previousMousePosition.x,
            y: event.clientY - previousMousePosition.y,
          };
          const rotateAngleX = ((deltaMove.y * Math.PI) / 180) * 0.5;
          const rotateAngleY = ((deltaMove.x * Math.PI) / 180) * 0.5;
          cube.rotation.x += rotateAngleX;
          cube.rotation.y += rotateAngleY;
          previousMousePosition = { x: event.clientX, y: event.clientY };
        }
      }

      function onMouseUp() {
        isDragging = false;
      }

      function onClick(event) {
        if (!isDragging) {
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(cube.children);
          if (intersects.length > 0) {
            const now = Date.now();
            const delta = now - lastClickTime;
            lastClickTime = now;
            if (delta < 300 && candrag) {
              new TWEEN.Tween(cube.position)
                .to({ x: -50, y: 5, z: -20 }, 1000)
                .easing(TWEEN.Easing.Exponential.InOut)
                .onComplete(function () {
                  rotationSpeed = 0;
                  //candrag = false;
                  const clickedFaceName = intersects[0].object.name;
                  showModal(clickedFaceName, cube);
                })
                .start();
            } else {
            }
          }
        }
      }

      function setupLighting() {
        const spotLight = new THREE.SpotLight(0xffffff, 1);
        spotLight.position.set(0, 20, 20);
        spotLight.angle = Math.PI / 2;
        spotLight.penumbra = 0.1;
        spotLight.decay = 0;
        spotLight.distance = 1000;
        spotLight.castShadow = true;
        scene.add(spotLight);
      }

      function createFloor() {
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0xf7f5da,
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5;
        floor.receiveShadow = true;
        scene.add(floor);
      }

      function animate() {
        if (!isDragging) {
          cube.rotation.x += rotationSpeed;
          cube.rotation.y += rotationSpeed;
          instructionPlane.lookAt(camera.position);
        }
        instructionPlane.visible = instructionVisible;
        requestAnimationFrame(animate);
        TWEEN.update();
        renderer.render(scene, camera);
      }
    </script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script>
      function showModal(faceName, cube) {
        var modal = document.createElement("div");
        modal.id = "modal";
        modal.style.display = "flex";
        document.body.appendChild(modal);

        const closeButton = document.createElement("button");
        closeButton.classList.add("close-btn");
        closeButton.innerHTML = "Close";
        closeButton.onclick = function () {
          document.body.removeChild(modal);
          candrag = true;
          isDragging = true;
          cube.position.set(0, 15, 40);
          rotationSpeed = 0.005;
          setInterval(() => {
            cube.rotation.x += rotationSpeed;
            cube.rotation.y += rotationSpeed;
          }, 1000 / 60);

          // Animate cube back to original position
        };
        modal.appendChild(closeButton);

        // Additional elements for canvas and toast
        const toast = document.createElement("div");
        toast.classList.add("toast");
        toast.textContent = "Click close button to close the animation";
        modal.appendChild(toast);
        const canvas = document.createElement("canvas");
        modal.appendChild(canvas);
        canvas.id = "temp";
        canvas.width = window.innerWidth * 0.98;
        canvas.height = window.innerHeight * 0.45;

        if (faceName === "front") {
          canvas.id = "frontFaceCanvas";
          modal.appendChild(canvas);
          initializeFrontFaceAnimation(canvas.id);
        } else if (faceName === "back") {
          canvas.id = "backFaceCanvas";
          modal.appendChild(canvas);
          initializeBackFaceAnimation();
        } else if (faceName === "left") {
          canvas.id = "leftFaceCanvas";
          modal.appendChild(canvas);
          initializeLeftFaceAnimation(canvas.id);
        } else if (faceName === "right") {
          canvas.id = "rightFaceCanvas";
          modal.appendChild(canvas);
          initializeRightFaceAnimation(canvas.id);
        } else if (faceName === "bottom") {
          canvas.id = "bottomFaceCanvas";
          modal.appendChild(canvas);
          initializeBottomFaceAnimation(canvas.id);
        } else if (faceName === "top") {
          canvas.id = "topFaceCanvas";
          modal.appendChild(canvas);
          initializeTopFaceAnimation(canvas.id);
          modal.addEventListener("click", function (event) {
            event.stopPropagation();
          });
        }
      }
      function showCubeInteractionToast() {
        const toast = document.createElement("div");
        //toast.classList.add("toast");
        toast.id = "cube_toast";
        toast.style.top = "5%";
        toast.textContent =
          "Drag the cube to rotate. Double-click a face to select and experience an animation pattern";
        document.body.appendChild(toast);
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 2000000); // Auto-remove after 10 seconds
      }

      //FrontFace Animation
      function initializeFrontFaceAnimation(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
          console.error("FrontFace canvas element not found");
          return;
        }
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth * 0.98; // Adjusted to match modal canvas width
        canvas.height = window.innerHeight * 0.45; // Adjusted to match modal canvas height

        let particlePositions = [];
        let particles = [];
        const letters = localStorage.getItem("userName") ? localStorage.getItem("userName") :"<APT/>";
        let currentPos = 0;
        let W = canvas.width;
        let H = canvas.height;

        function Particle(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 3;

          this.draw = function () {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.fillStyle = "rgb(10,242,122)";
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * 0.5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
          };
        }

        function changeLetter() {
          time = letters[currentPos];
          currentPos = (currentPos + 1) % letters.length;
        }

        function makeParticles(num) {
          for (let i = 0; i <= num; i++) {
            particles.push(
              new Particle(
                W / 2 + Math.random() * 400 - 200,
                H / 2 + Math.random() * 400 - 200
              )
            );
          }
        }

        function getPixels() {
          const keyword = letters[currentPos],
            gridX = 5,
            gridY = 5;

          const tmpCanvas = document.createElement("canvas"),
            tmpCtx = tmpCanvas.getContext("2d");

          tmpCanvas.width = W;
          tmpCanvas.height = H;
          tmpCtx.fillStyle = "red";
          tmpCtx.font = "italic bold 400px Noto Serif";
          const textHeight = 500; // Approximation of text height, adjust as needed
          tmpCtx.fillText(
            keyword,
            W / 2 - tmpCtx.measureText(keyword).width / 1.5,
            H / 2 + textHeight / 4
          );

          const idata = tmpCtx.getImageData(
              0,
              0,
              tmpCanvas.width,
              tmpCanvas.height
            ),
            buffer32 = new Uint32Array(idata.data.buffer);

          particlePositions = [];
          for (let y = 0; y < tmpCanvas.height; y += gridY) {
            for (let x = 0; x < tmpCanvas.width; x += gridX) {
              if (buffer32[y * tmpCanvas.width + x]) {
                particlePositions.push({ x, y });
              }
            }
          }
        }

        function animateParticles() {
          for (let i = 0, num = particles.length; i < num; i++) {
            const p = particles[i],
              pPos = particlePositions[i];
            if (pPos) {
              p.x += (pPos.x - p.x) * 0.3;
              p.y += (pPos.y - p.y) * 0.3;
              p.draw();
            }
          }
        }

        function animate() {
          requestAnimationFrame(animate);
          ctx.fillStyle = "rgba(9, 5, 77, 1)";
          ctx.fillRect(0, 0, W, H);
          animateParticles();
        }

        // Initialize the animation
        setInterval(() => {
          changeLetter();
          getPixels();
        }, 900);

        makeParticles(10000);
        animate();
      }
      //BackFace Animation
      function initializeBackFaceAnimation() {
        const canvas = document.getElementById("backFaceCanvas");
        if (!canvas) {
          console.error("BackFace canvas element not found");
          return;
        }
        const ctx = canvas.getContext("2d", {
          willReadFrequently: true,
        });
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const colors = [
          "#FF4500", // Orangered
          "#00CED1", // Dark Turquoise
          "#FF00FF", // Magenta
          "#FFFF00", // Yellow
          "#7FFFD4", // Aquamarine
          "#FF1493", // Deep Pink
          "#00FF00", // Lime
          "#8A2BE2", // Blue Violet
          "#FF6347", // Tomato
          "#00FFFF", // Cyan
          "#FF8C00", // Dark Orange
          "#9400D3", // Dark Violet
        ];

        const userName = localStorage.getItem("userName") ? localStorage.getItem("userName") :"<APT/>";

        class Particle {
          constructor(effect, x, y) {
            this.effect = effect;
            this.x = Math.random() * this.effect.canvasWidth;
            this.y = Math.random() * this.effect.canvasHeight;
            this.originX = Math.floor(x);
            this.originY = Math.floor(y);
            this.size = Math.random() * 5 + 5;
            this.color = colors[Math.floor(Math.random() * colors.length)];
            this.dx = 0;
            this.dy = 0;
            this.vx = 0;
            this.vy = 0;
            this.force = 10;
            this.angle = 0;
            this.distance = 0;
            this.friction = 0.8;
            this.ease = 1;
          }
          update() {
            this.dx = this.effect.mouse.x - this.x;
            this.dy = this.effect.mouse.y - this.y;
            this.distance = this.dx * this.dx + this.dy * this.dy;
            this.force = -this.effect.mouse.radius / this.distance;
            if (this.distance < this.effect.mouse.radius) {
              this.angle = Math.atan2(this.dy, this.dx);
              this.vx += this.force * Math.cos(this.angle);
              this.vy += this.force * Math.sin(this.angle);
            }
            this.x +=
              (this.vx *= this.friction) + (this.originX - this.x) * this.ease;
            this.y +=
              (this.vy *= this.friction) + (this.originY - this.y) * this.ease;
          }
          draw() {
            this.effect.context.fillStyle = this.color;
            this.effect.context.beginPath();
            this.effect.context.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
            this.effect.context.fill();
          }
        }

        class Effect {
          constructor(context, canvasWidth, canvasHeight) {
            this.context = context;
            this.canvasWidth = canvasWidth;
            this.canvasHeight = canvasHeight;
            this.particles = [];
            this.gap = 5;
            this.mouse = {
              radius: 800 * 800,
              x: undefined,
              y: undefined,
            };
            window.addEventListener("mousemove", (event) => {
              const rect = canvas.getBoundingClientRect();
              const scaleX = canvas.width / rect.width;
              const scaleY = canvas.height / rect.height;
              this.mouse.x = (event.clientX - rect.left) * scaleX;
              this.mouse.y = (event.clientY - rect.top) * scaleY;
            });
            window.addEventListener("mouseout", () => {
              this.mouse.x = undefined;
              this.mouse.y = undefined;
            });
            this.wrapText(userName);
          }
          wrapText(text) {
            this.context.font = "500px Arial";
            this.context.fillStyle = "white";
            this.context.textAlign = "center";
            this.context.fillText(
              text,
              this.canvasWidth / 2,
              this.canvasHeight / 1.8
            );
            this.convertToParticles();
          }
          convertToParticles() {
            this.particles = [];
            const imageData = this.context.getImageData(
              0,
              0,
              this.canvasWidth,
              this.canvasHeight
            );
            const data = imageData.data;
            for (let y = 0; y < this.canvasHeight; y += this.gap) {
              for (let x = 0; x < this.canvasWidth; x += this.gap) {
                const index = (y * this.canvasWidth + x) * 4;
                if (data[index + 3] > 128) {
                  this.particles.push(new Particle(this, x, y));
                }
              }
            }
          }
          render() {
            this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            this.particles.forEach((particle) => {
              particle.update();
              particle.draw();
            });
          }
        }

        let effect = new Effect(ctx, canvas.width, canvas.height);

        function animate() {
          effect.render();
          requestAnimationFrame(animate);
        }
        animate();

        window.addEventListener("resize", function () {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          effect = new Effect(ctx, canvas.width, canvas.height);
          effect.wrapText(userName); // Re-generate text and particles for new dimensions
        });
      }
      //BottomFace Animation
      function initializeBottomFaceAnimation(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
          console.error("Canvas element not found");
          return;
        }
      
        // Initialize WebGL context
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
          console.error("Unable to initialize WebGL. Your browser may not support it.");
          return;
        }
      
        // Vertex shader program
        const vsSource = `
          attribute vec4 aVertexPosition;
          uniform float uPointSize;
          void main(void) {
            gl_Position = aVertexPosition;
            gl_PointSize = uPointSize;
          }
        `;
      
        // Fragment shader program
        const fsSource = `
          precision mediump float;
          uniform vec4 uColor;
          void main(void) {
            gl_FragColor = uColor;
          }
        `;
      
        // Initialize shader program
        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
        const programInfo = {
          program: shaderProgram,
          attribLocations: {
            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
          },
          uniformLocations: {
            pointSize: gl.getUniformLocation(shaderProgram, 'uPointSize'),
            color: gl.getUniformLocation(shaderProgram, 'uColor'),
          },
        };
      
        // Define particles here (e.g., positions, sizes)
        // For simplicity, we're just creating a single particle at the center
        const particles = [
          0.0, 0.0, 0.0,
        ];
      
        // Create buffer for particle positions
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particles), gl.STATIC_DRAW);
      
        function render() {
          gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
          gl.clearDepth(1.0);                 // Clear everything
          gl.enable(gl.DEPTH_TEST);           // Enable depth testing
          gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
      
          // Clear the canvas before we start drawing on it.
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      
          // Tell WebGL to use our program when drawing
          gl.useProgram(programInfo.program);
      
          // Set shader uniforms
          gl.uniform1f(programInfo.uniformLocations.pointSize, 10.0); // Set point size
          gl.uniform4f(programInfo.uniformLocations.color, 1.0, 1.0, 1.0, 1.0); // Set color to white
      
          // Set the positions of the vertices
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
          gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
      
          gl.drawArrays(gl.POINTS, 0, particles.length / 3);
          requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
      }
      
      // Initialize a shader program; this is where all the lighting
      // for the vertices and so forth is established.
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
      
        // Create the shader program
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
      
        // If creating the shader program failed, alert
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
          return null;
        }
      
        return shaderProgram;
      }
      
      // Creates a shader of the given type, uploads the source and
      // compiles it.
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
      
        // Send the source to the shader object
        gl.shaderSource(shader, source);
      
        // Compile the shader program
        gl.compileShader(shader);
      
        // See if it compiled successfully
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
      
        return shader;
      }
      
      // Use this function to start the animation
      // initializeBottomFaceAnimation('yourCanvasId');
      //RightFace Animation
      async function initializeRightFaceAnimation(canvasId) {
        if (typeof BABYLON === "undefined") {
          await import("https://cdn.babylonjs.com/babylon.js");
          await import(
            "https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"
          );
        }

        const canvas = document.getElementById(canvasId);
        if (!canvas) {
          console.error("RightFace canvas element not found");
          return;
        }

        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.03, 0.03, 0.12, 1); // Dark navy blue background
        const sphericalContainer = new BABYLON.TransformNode(
          "sphericalContainer"
        );
        const camera = new BABYLON.ArcRotateCamera(
          "Camera",
          -Math.PI / 2,
          Math.PI / 2,
          130,
          new BABYLON.Vector3(0, 0, 0),
          scene
        );
        camera.attachControl(canvas, true);

        const light = new BABYLON.HemisphericLight(
          "light1",
          new BABYLON.Vector3(1, 1, 0),
          scene
        );

        const glowLayer = new BABYLON.GlowLayer("glow", scene);
        glowLayer.intensity = 0.6;

        const letters = localStorage.getItem("userName") ? localStorage.getItem("userName").split('') : ["A", "P", "T"];
        const planets = [];

        const RADIUS = 100; // Radius of the spherical volume
        const NUM_PLANETS = 1500; // Total number of planets

        for (let i = 0; i < NUM_PLANETS; i++) {
          const letter = letters[i % letters.length];
          const planet = createLetterPlanet(letter, i, RADIUS, scene);
          planets.push(planet);
        }
        engine.runRenderLoop(() => {
          sphericalContainer.rotation.y += 0.001; // Adjust the value for different speeds
          scene.render();
        });
        let mouseWorldPosition = new BABYLON.Vector3(0, 0, 0);
        window.addEventListener("mousemove", function (event) {
          const pickResult = scene.pick(event.clientX, event.clientY);
          if (pickResult.hit) {
            mouseWorldPosition = pickResult.pickedPoint;
          }
        });
        function createLetterPlanet(letter, index, radius, scene) {
          const size = 50; // Size of the dynamic texture
          const dynamicTexture = new BABYLON.DynamicTexture(
            "DynamicTexture",
            { width: size, height: size },
            scene,
            true
          );
          dynamicTexture.drawText(
            letter,
            10,
            40,
            "bold 40px Arial",
            "#07F7DF",
            "transparent",
            true
          );
          dynamicTexture.hasAlpha = true;

          const plane = BABYLON.MeshBuilder.CreatePlane(
            "textPlane",
            { size: 1 },
            scene
          );
          plane.parent = sphericalContainer;

          // Calculate the position of the planet within the spherical volume
          const r = Math.cbrt(Math.random()) * radius;
          const theta = Math.random() * 2 * Math.PI;
          const phi = Math.acos(2 * Math.random() - 1);
          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.sin(phi) * Math.sin(theta);
          const z = r * Math.cos(phi);

          plane.position = new BABYLON.Vector3(x, y, z);
          plane.lookAt(new BABYLON.Vector3(0, 0, 0)); // Make the plane face the center

          const material = new BABYLON.StandardMaterial(
            "TextPlaneMaterial",
            scene
          );
          material.diffuseTexture = dynamicTexture;
          material.emissiveColor = new BABYLON.Color3.FromHexString("#07F7DF"); // Bright neon blue
          material.useAlphaFromDiffuseTexture = true;
          plane.material = material;

          glowLayer.addIncludedOnlyMesh(plane);

          return plane;
        }

        engine.runRenderLoop(() => {
          scene.render();
        });

        window.addEventListener("resize", () => {
          engine.resize();
        });
      }

      //LeftFace Animation
      function initializeLeftFaceAnimation(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
          console.error("LeftFace canvas element not found");
          return;
        }

        const ctx = canvas.getContext("2d");
        let w, h;
        let hue;
        let particles;
        let spikeLength;
        let planets;
        let A;
        let B;
        let a;
        let b;
        let tick;

        const config = {
          text: localStorage.getItem("userName") ? localStorage.getItem("userName") :"<APT/>",
          widthToSpikeLengthRatio: 0.054,
        };

        const colorConfig = {
          particleOpacity: 0.2,
          baseHue: 350,
          hueRange: 9,
          hueSpeed: 0.04,
          colorSaturation: 100,
        };

        function setup() {
          tick = 0;
          planets = [];
          let len = Math.round(Math.random() * 3 + 3);
          for (let i = 0; i < len; i++) {
            let p = new Planet(50 + i * 100, 340, i ? 1000 : 4000);
            planets.push(p);
          }
          window.addEventListener("resize", reset);
          canvas.addEventListener("mousemove", mousemove);
          reset();
        }

        function reset() {
          hue = colorConfig.baseHue;
          w = canvas.width = window.innerWidth;
          h = canvas.height = window.innerHeight;
          spikeLength = w * config.widthToSpikeLengthRatio;
          A = w / 2.2;
          B = h / 2.2;
          a = Math.round(Math.random() + 2);
          b = Math.round(Math.random() + 2);
          drawText();
        }

        function mousemove(event) {
          let x = event.clientX;
          let y = event.clientY;
          planets[0].pos.x = x;
          planets[0].pos.y = y;
        }

        function draw(now) {
          clear();
          requestAnimationFrame(draw);
          updateParticles();
          updatePlanets();
          tick = now / 50;
        }

        function clear() {
          ctx.clearRect(0, 0, w, h);
        }

        function drawText() {
          ctx.save();
          let fontSize = w * 0.2;
          ctx.font = "bold " + fontSize + "px Arial, Helvetica, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.lineWidth = 1;
          ctx.strokeStyle = "white";
          ctx.strokeText(config.text, w / 2, h / 2);
          ctx.restore();
          let imageData = ctx.getImageData(0, 0, w, h);

          particles = [];

          let skipFactor = 2;

          for (let x = 0; x < w; x += skipFactor) {
            for (let y = 0; y < h; y += skipFactor) {
              let i = (x + w * y) * 4;
              let average =
                (imageData.data[i] +
                  imageData.data[i + 1] +
                  imageData.data[i + 2] +
                  imageData.data[i + 3]) /
                4;
              if (average > 200) {
                let particle = new Particle(x, y);
                particles.push(particle);
              }
            }
          }
          clear();
        }

        function updatePlanets() {
          let len = planets.length;
          for (let i = 1; i < len; i++) {
            let angle = ((Math.PI * 2) / (len - 1)) * i;
            let x = A * Math.sin((a * tick) / 100 + angle) + w / 2;
            let y = B * Math.sin((b * tick) / 100 + angle) + h / 2;
            let p = planets[i];
            p.pos.x = x;
            p.pos.y = y;
            p.draw();
          }
        }

        function updateParticles() {
          hue += colorConfig.hueSpeed;
          let h = Math.sin(hue) * colorConfig.hueRange + colorConfig.baseHue;
          ctx.strokeStyle = `hsla(180, 100%, 50%, 1)`;
          particles.forEach((p) => {
            planets.forEach((planet) => {
              let d = p.pos.sub(planet.pos);
              let length = d.getLength();
              let g = planet.g / length;
              if (g > 40) {
                g = 40;
              }
              d.setLength(g);
              p.move(d);
            });
            p.draw();
          });
        }

        class Vector {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }

          add(v) {
            return new Vector(this.x + v.x, this.y + v.y);
          }

          sub(v) {
            return new Vector(this.x - v.x, this.y - v.y);
          }

          getLength() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }

          setLength(length) {
            var angle = this.getAngle();
            this.x = Math.cos(angle) * length;
            this.y = Math.sin(angle) * length;
          }

          getAngle() {
            return Math.atan2(this.y, this.x);
          }

          addTo(v) {
            this.x += v.x;
            this.y += v.y;
          }

          multiplyBy(value) {
            this.x *= value;
            this.y *= value;
          }

          setAngle(angle) {
            var length = this.getLength();
            this.x = Math.cos(angle) * length;
            this.y = Math.sin(angle) * length;
          }
        }

        class Planet {
          constructor(x, y, g) {
            this.pos = new Vector(x, y);
            this.g = g;
          }

          draw() {
            // ctx.beginPath();
            // ctx.fillStyle = "white";
            // ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI * 2);
            // ctx.fill();
          }
        }

        class Particle {
          constructor(x, y) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(0, spikeLength);
          }

          move(force) {
            if (force) {
              this.vel.addTo(force);
            }
            if (this.vel.getLength() > spikeLength) {
              this.vel.setLength(spikeLength);
            }
          }

          draw() {
            let p2 = this.pos.add(this.vel);
            let gradient = ctx.createLinearGradient(
              this.pos.x,
              this.pos.y,
              p2.x,
              p2.y
            );
            gradient.addColorStop(0, "rgba(0, 255, 255, 0)");
            gradient.addColorStop(1, "rgba(0, 255, 255, 1)");

            ctx.beginPath();
            ctx.moveTo(this.pos.x, this.pos.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = gradient;
            ctx.stroke();
          }
        }

        setup();
        draw(1);
      }
      //TopFace Animation
      function initializeTopFaceAnimation(canvasId) {
        let engine, scene, camera;
        let letters = [];
        let ripples = [];
        let water;
        init();
        animate();
  
        function init() {
          const canvas = document.getElementById(canvasId);
          if (!canvas) {
            console.error("TopFace canvas element not found");
            return;
          }
  
          engine = new BABYLON.Engine(canvas, true);
          scene = new BABYLON.Scene(engine);
          var background = new BABYLON.Layer("back", null, scene);
    background.texture = new BABYLON.DynamicTexture("dynaTexture", 1024, scene, true);
    var textureContext = background.texture.getContext();

    var grd = textureContext.createRadialGradient(512, 512, 0, 512, 512, 512);
    grd.addColorStop(0, "navy");
    grd.addColorStop(0.8, "#010a30");
    textureContext.fillStyle = grd;
    textureContext.fillRect(0, 0, 1024, 1024);
    background.texture.update();
          //scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);
  
          camera = new BABYLON.ArcRotateCamera(
            "Camera",
            -Math.PI / 2,
            70*(Math.PI/180) ,
            340,
            new BABYLON.Vector3(0, 0, 0),
            scene
          );
          camera.attachControl(canvas, true);
  
          new BABYLON.HemisphericLight(
            "light1",
            new BABYLON.Vector3(1, 1, 0),
            scene
          ).intensity = 0.7;
  
          waterMaterial = new BABYLON.StandardMaterial("waterMaterial", scene);
          waterMaterial.diffuseColor = new BABYLON.Color4(0, 0, 0, 0.3);
          waterMaterial.alpha = 0.6;
          water = BABYLON.MeshBuilder.CreateGround(
            "water",
            { width: 1000, height: 3300 },
            scene
          );
          water.material = waterMaterial;
          water.position.y = -30;
  
          createTextParticles();
        }
  
        function createTextParticles() {
          const lettersOptions = localStorage.getItem("userName") ? localStorage.getItem("userName").split('') :["A", "P", "T"];
  
          lettersOptions.forEach((letter) => {
            for (let i = 0; i < 300; i++) {
              const plane = BABYLON.MeshBuilder.CreatePlane(
                "textPlane",
                { width: 4, height: 4 },
                scene
              );
              const dynamicTexture = new BABYLON.DynamicTexture(
                "DynamicTexture",
                512,
                scene,
                true
              );
              dynamicTexture.drawText(
                letter,
                75,
                400,
                "bold 440px Arial",
                "#34e8eb",
                "transparent",
                true
              );
              dynamicTexture.hasAlpha = true;
  
              const material = new BABYLON.StandardMaterial(
                "TextPlaneMaterial",
                scene
              );
              material.diffuseTexture = dynamicTexture;
              material.emissiveColor = new BABYLON.Color4(0, 1, 1, 0.5);
              material.useAlphaFromDiffuseTexture = true;
  
              plane.material = material;
              plane.position = new BABYLON.Vector3(
                Math.random() * 300 - 150,
                Math.random() * 90 + 30,
                Math.random() * 300 - 150
              );
              plane.metadata = { velocity: -Math.random() * 0.5 - 0.5 };
  
              letters.push(plane);
            }
          });
        }
  
        function createRipple(position) {
          const ripple = BABYLON.MeshBuilder.CreateTorus(
            "ripple",
            { diameter: 1.5, thickness: 0.15, tessellation: 32 },
            scene
          );
          ripple.position = new BABYLON.Vector3(
            position.x,
            water.position.y - 20,
            position.z - 20
          );
          ripple.rotation.x = Math.PI / 2;
          const material = new BABYLON.StandardMaterial("rippleMat", scene);
          material.diffuseColor = new BABYLON.Color3(0, 1, 1);
          material.emissiveColor = new BABYLON.Color3(0, 1, 1);
          material.alpha = 1;
          ripple.material = material;
  
          ripples.push({
            mesh: ripple,
            scale: 1,
            alpha: material.alpha,
            maxSize: 9,
          });
        }
  
        function animate() {
          engine.runRenderLoop(() => {
            letters.forEach((letter) => {
              letter.position.y += letter.metadata.velocity;
              if (letter.position.y < -90) {
                const impactPosition = new BABYLON.Vector3(
                  letter.position.x,
                  -4.95,
                  letter.position.z
                );
                createRipple(impactPosition);
                letter.position.y = 90 + Math.random() * 30;
                letter.position.x = Math.random() * 300 - 150;
                letter.position.z = Math.random() * 300 - 150;
              }
            });
  
            ripples.forEach((ripple, index) => {
              ripple.scale += 0.05;
              ripple.alpha -= 0.02;
              ripple.mesh.scaling.x = ripple.mesh.scaling.y = ripple.scale;
              ripple.mesh.material.alpha = ripple.alpha;
  
              if (ripple.scale > ripple.maxSize || ripple.alpha <= 0) {
                ripple.mesh.dispose();
                ripples.splice(index, 1);
              }
            });
  
            scene.render();
          });
        }
      }
  
      function createParticle(x, y, spikeLength, scene) {
        const particle = new BABYLON.Mesh("particle", scene);
        particle.position.x = x;
        particle.position.y = y;
        particle.position.z = 0;

        const material = new BABYLON.StandardMaterial(
          "particleMaterial",
          scene
        );
        material.diffuseColor = new BABYLON.Color3(0, 1, 1);
        material.alpha = 1;
        particle.material = material;

        const direction = new BABYLON.Vector3(0, spikeLength, 0);
        const length = direction.length();
        particle.scaling.y = length;
        particle.lookAt(particle.position.add(direction));

        return particle;
      }

      function createPlanet(x, y, g, scene) {
        const planet = new BABYLON.Mesh("planet", scene);
        planet.position.x = x;
        planet.position.y = y;
        planet.position.z = 0;
        planet.g = g;
        return planet;
      }

      function updatePlanets(planets, tick, width, height) {
        const len = planets.length;
        const A = width / 2.2;
        const B = height / 2.2;
        const a = Math.round(Math.random() + 2);
        const b = Math.round(Math.random() + 2);

        for (let i = 1; i < len; i++) {
          const angle = ((Math.PI * 2) / (len - 1)) * i;
          const x = A * Math.sin((a * tick) / 100 + angle) + width / 2;
          const y = B * Math.sin((b * tick) / 100 + angle) + height / 2;
          const planet = planets[i];
          planet.position.x = x;
          planet.position.y = y;
        }
      }

      function updateParticles(particles, planets, spikeLength, scene) {
        particles.forEach((particle) => {
          let force = BABYLON.Vector3.Zero();

          planets.forEach((planet) => {
            const direction = particle.position.subtract(planet.position);
            const length = direction.length();
            const g = planet.g / length;
            const limitedG = Math.min(g, 40);
            force.addInPlace(direction.normalize().scale(limitedG));
          });

          const velocity = force;
          const limitedVelocity = BABYLON.Vector3.Clamp(
            velocity,
            new BABYLON.Vector3(-spikeLength, -spikeLength, -spikeLength),
            new BABYLON.Vector3(spikeLength, spikeLength, spikeLength)
          );

          particle.position.addInPlace(limitedVelocity);

          const p2 = particle.position.add(limitedVelocity);

          const positions = [
            new BABYLON.Vector3(
              particle.position.x,
              particle.position.y,
              particle.position.z
            ),
            new BABYLON.Vector3(p2.x, p2.y, p2.z),
          ];

          const colors = [
            new BABYLON.Color4(0, 1, 1, 0),
            new BABYLON.Color4(0, 1, 1, 1),
          ];

          const linesMesh = BABYLON.MeshBuilder.CreateLines(
            "lines",
            { points: positions, colors: colors },
            scene
          );
        });
      }
      function createParticles(scene) {
        const AMOUNTX = 50,
          AMOUNTY = 50;
        const SEPARATION = 100;

        // Generate particles
        for (let i = 0; i < AMOUNTX; i++) {
          for (let j = 0; j < AMOUNTY; j++) {
            const box = BABYLON.MeshBuilder.CreateBox(
              "box",
              { size: 10 },
              scene
            );
            box.position.x = i * SEPARATION - (AMOUNTX * SEPARATION) / 2;
            box.position.z = j * SEPARATION - (AMOUNTY * SEPARATION) / 2;
            box.position.y = 0; // Adjust as necessary

          }
        }


      }
    </script>
  </body>
</html>
